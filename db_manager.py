#!/usr/bin/env python3
"""
Database Manager cho R|Trader Pro Data Collection
C√¥ng c·ª• d·ªÖ s·ª≠ d·ª•ng cho trader - kh√¥ng c·∫ßn bi·∫øt code!
"""

import os
import sys
import psycopg2
import pandas as pd
from datetime import datetime, timedelta
from tabulate import tabulate
import json

class DatabaseManager:
    def __init__(self):
        # K·∫øt n·ªëi database
        self.db_config = {
            'host': 'localhost',
            'port': 5432,
            'database': 'rithmic_db',
            'user': 'postgres',
            'password': 'postgres'  # Password t·ª´ docker-compose.yml
        }
        self.conn = None
        
    def connect(self):
        """K·∫øt n·ªëi database"""
        try:
            self.conn = psycopg2.connect(**self.db_config)
            print("‚úÖ ƒê√£ k·∫øt n·ªëi database th√†nh c√¥ng!")
            return True
        except Exception as e:
            print(f"‚ùå L·ªói k·∫øt n·ªëi database: {e}")
            print("\nüìù H∆∞·ªõng d·∫´n:")
            print("1. ƒê·∫£m b·∫£o Docker Desktop ƒëang ch·∫°y")
            print("2. Ch·∫°y: docker-compose up -d")
            print("3. ƒê·ª£i 30 gi√¢y r·ªìi th·ª≠ l·∫°i")
            return False
    
    def show_menu(self):
        """Hi·ªÉn th·ªã menu ch√≠nh"""
        print("\n" + "="*60)
        print("üîß QU·∫¢N L√ù DATABASE R|TRADER PRO")
        print("="*60)
        print("1. üìä Xem th·ªëng k√™ d·ªØ li·ªáu")
        print("2. üìà Xem d·ªØ li·ªáu tick g·∫ßn nh·∫•t")
        print("3. üìâ Xem d·ªØ li·ªáu Level 2")
        print("4. ‚ûï Th√™m symbol m·ªõi")
        print("5. üìã Xem danh s√°ch symbols")
        print("6. üíæ Export d·ªØ li·ªáu ra CSV")
        print("7. üóëÔ∏è  X√≥a d·ªØ li·ªáu c≈©")
        print("8. üì¶ Backup database")
        print("9. üìÇ Restore database")
        print("10. ‚ÑπÔ∏è  Th√¥ng tin k·∫øt n·ªëi")
        print("0. ‚ùå Tho√°t")
        print("="*60)
        
    def show_statistics(self):
        """Xem th·ªëng k√™ d·ªØ li·ªáu"""
        cursor = self.conn.cursor()
        
        print("\nüìä TH·ªêNG K√ä D·ªÆ LI·ªÜU")
        print("-"*60)
        
        # T·ªïng s·ªë tick data
        cursor.execute("SELECT COUNT(*) FROM tick_data")
        total_ticks = cursor.fetchone()[0]
        print(f"üìà T·ªïng s·ªë tick data: {total_ticks:,}")
        
        # T·ªïng s·ªë level2 data
        cursor.execute("SELECT COUNT(*) FROM level2_data")
        total_level2 = cursor.fetchone()[0]
        print(f"üìâ T·ªïng s·ªë Level 2 data: {total_level2:,}")
        
        # Th·ªëng k√™ theo symbol
        print("\nüìä Th·ªëng k√™ theo Symbol:")
        cursor.execute("""
            SELECT symbol, 
                   COUNT(*) as tick_count,
                   MIN(timestamp) as first_tick,
                   MAX(timestamp) as last_tick
            FROM tick_data
            GROUP BY symbol
            ORDER BY tick_count DESC
        """)
        
        data = cursor.fetchall()
        if data:
            headers = ["Symbol", "S·ªë l∆∞·ª£ng", "Tick ƒë·∫ßu ti√™n", "Tick cu·ªëi c√πng"]
            print(tabulate(data, headers=headers, tablefmt="grid"))
        else:
            print("‚ö†Ô∏è  Ch∆∞a c√≥ d·ªØ li·ªáu!")
            
        cursor.close()
    
    def show_recent_ticks(self):
        """Xem tick data g·∫ßn nh·∫•t"""
        symbol = input("\nüìä Nh·∫≠p symbol (ho·∫∑c Enter ƒë·ªÉ xem t·∫•t c·∫£): ").upper()
        limit = input("üìä S·ªë l∆∞·ª£ng tick mu·ªën xem (m·∫∑c ƒë·ªãnh 20): ")
        limit = int(limit) if limit else 20
        
        cursor = self.conn.cursor()
        
        if symbol:
            query = """
                SELECT timestamp, symbol, price, size, bid_price, ask_price
                FROM tick_data
                WHERE symbol = %s
                ORDER BY timestamp DESC
                LIMIT %s
            """
            cursor.execute(query, (symbol, limit))
        else:
            query = """
                SELECT timestamp, symbol, price, size, bid_price, ask_price
                FROM tick_data
                ORDER BY timestamp DESC
                LIMIT %s
            """
            cursor.execute(query, (limit,))
        
        data = cursor.fetchall()
        if data:
            headers = ["Th·ªùi gian", "Symbol", "Gi√°", "Size", "Bid", "Ask"]
            print(f"\nüìà {limit} tick g·∫ßn nh·∫•t:")
            print(tabulate(data, headers=headers, tablefmt="grid"))
        else:
            print("‚ö†Ô∏è  Kh√¥ng c√≥ d·ªØ li·ªáu!")
            
        cursor.close()
    
    def show_level2_data(self):
        """Xem Level 2 data"""
        symbol = input("\nüìä Nh·∫≠p symbol: ").upper()
        
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT timestamp, side, level, price, size
            FROM level2_data
            WHERE symbol = %s AND timestamp = (
                SELECT MAX(timestamp) FROM level2_data WHERE symbol = %s
            )
            ORDER BY side DESC, level
        """, (symbol, symbol))
        
        data = cursor.fetchall()
        if data:
            print(f"\nüìâ Level 2 data cho {symbol}:")
            bids = [(d[2], d[3], d[4]) for d in data if d[1] == 'B']
            asks = [(d[2], d[3], d[4]) for d in data if d[1] == 'S']
            
            print("\nüü¢ BIDS:")
            print(tabulate(bids, headers=["Level", "Price", "Size"], tablefmt="grid"))
            
            print("\nüî¥ ASKS:")
            print(tabulate(asks, headers=["Level", "Price", "Size"], tablefmt="grid"))
        else:
            print(f"‚ö†Ô∏è  Kh√¥ng c√≥ Level 2 data cho {symbol}!")
            
        cursor.close()
    
    def add_symbol(self):
        """Th√™m symbol m·ªõi"""
        symbol = input("\nüìä Nh·∫≠p symbol m·ªõi (VD: ESH5): ").upper()
        exchange = input("üìä Nh·∫≠p exchange (m·∫∑c ƒë·ªãnh CME): ") or "CME"
        
        cursor = self.conn.cursor()
        try:
            cursor.execute("""
                INSERT INTO symbols (symbol, exchange, active)
                VALUES (%s, %s, TRUE)
                ON CONFLICT (symbol) DO UPDATE SET active = TRUE
            """, (symbol, exchange))
            self.conn.commit()
            print(f"‚úÖ ƒê√£ th√™m symbol {symbol} tr√™n {exchange}!")
            
            # Th√¥ng b√°o cho collector
            import redis
            r = redis.Redis(host='localhost', port=6379)
            r.rpush('symbol_subscriptions', json.dumps({
                'symbol': symbol,
                'exchange': exchange
            }))
            print("üì§ ƒê√£ g·ª≠i y√™u c·∫ßu subscribe ƒë·∫øn collector!")
            
        except Exception as e:
            print(f"‚ùå L·ªói: {e}")
            self.conn.rollback()
        
        cursor.close()
    
    def list_symbols(self):
        """Xem danh s√°ch symbols"""
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT s.symbol, s.exchange, s.active, 
                   COUNT(t.id) as tick_count,
                   MAX(t.timestamp) as last_update
            FROM symbols s
            LEFT JOIN tick_data t ON s.symbol = t.symbol
            GROUP BY s.symbol, s.exchange, s.active
            ORDER BY s.symbol
        """)
        
        data = cursor.fetchall()
        if data:
            print("\nüìã Danh s√°ch Symbols:")
            headers = ["Symbol", "Exchange", "Active", "Ticks", "C·∫≠p nh·∫≠t cu·ªëi"]
            formatted_data = []
            for row in data:
                formatted_data.append([
                    row[0], row[1], 
                    "‚úÖ" if row[2] else "‚ùå",
                    f"{row[3]:,}" if row[3] else "0",
                    row[4].strftime("%Y-%m-%d %H:%M:%S") if row[4] else "N/A"
                ])
            print(tabulate(formatted_data, headers=headers, tablefmt="grid"))
        else:
            print("‚ö†Ô∏è  Ch∆∞a c√≥ symbol n√†o!")
            
        cursor.close()
    
    def export_to_csv(self):
        """Export d·ªØ li·ªáu ra CSV"""
        symbol = input("\nüìä Nh·∫≠p symbol c·∫ßn export: ").upper()
        days = input("üìä S·ªë ng√†y d·ªØ li·ªáu (m·∫∑c ƒë·ªãnh 1): ")
        days = int(days) if days else 1
        
        # T·∫°o th∆∞ m·ª•c export n·∫øu ch∆∞a c√≥
        os.makedirs("exports", exist_ok=True)
        
        # Export tick data
        query = """
            SELECT * FROM tick_data
            WHERE symbol = %s 
            AND timestamp > NOW() - INTERVAL '%s days'
            ORDER BY timestamp
        """
        
        df = pd.read_sql(query, self.conn, params=(symbol, days))
        if not df.empty:
            filename = f"exports/{symbol}_ticks_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            df.to_csv(filename, index=False)
            print(f"‚úÖ ƒê√£ export {len(df)} tick records ƒë·∫øn {filename}")
        else:
            print("‚ö†Ô∏è  Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ export!")
    
    def cleanup_old_data(self):
        """X√≥a d·ªØ li·ªáu c≈©"""
        days = input("\nüìä X√≥a d·ªØ li·ªáu c≈© h∆°n bao nhi√™u ng√†y? (m·∫∑c ƒë·ªãnh 30): ")
        days = int(days) if days else 30
        
        confirm = input(f"‚ö†Ô∏è  B·∫°n ch·∫Øc ch·∫Øn mu·ªën x√≥a d·ªØ li·ªáu c≈© h∆°n {days} ng√†y? (y/N): ")
        if confirm.lower() != 'y':
            print("‚ùå ƒê√£ h·ªßy!")
            return
        
        cursor = self.conn.cursor()
        
        # X√≥a tick data c≈©
        cursor.execute("""
            DELETE FROM tick_data 
            WHERE timestamp < NOW() - INTERVAL '%s days'
        """, (days,))
        tick_deleted = cursor.rowcount
        
        # X√≥a level2 data c≈©
        cursor.execute("""
            DELETE FROM level2_data 
            WHERE timestamp < NOW() - INTERVAL '%s days'
        """, (days,))
        level2_deleted = cursor.rowcount
        
        self.conn.commit()
        cursor.close()
        
        print(f"‚úÖ ƒê√£ x√≥a {tick_deleted:,} tick records v√† {level2_deleted:,} level2 records!")
    
    def backup_database(self):
        """Backup database"""
        print("\nüì¶ Backup Database")
        backup_name = input("üì¶ T√™n file backup (m·∫∑c ƒë·ªãnh: rithmic_backup_[timestamp]): ")
        
        if not backup_name:
            backup_name = f"rithmic_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # T·∫°o th∆∞ m·ª•c backup n·∫øu ch∆∞a c√≥
        os.makedirs("backups", exist_ok=True)
        
        backup_file = f"backups/{backup_name}.sql"
        
        # Ch·∫°y pg_dump
        cmd = f'docker-compose exec -T db pg_dump -U postgres rithmic_db > {backup_file}'
        
        print(f"‚è≥ ƒêang backup database...")
        result = os.system(cmd)
        
        if result == 0:
            print(f"‚úÖ Backup th√†nh c√¥ng: {backup_file}")
            # Ki·ªÉm tra k√≠ch th∆∞·ªõc file
            size = os.path.getsize(backup_file) / (1024 * 1024)  # MB
            print(f"üìä K√≠ch th∆∞·ªõc: {size:.2f} MB")
        else:
            print("‚ùå Backup th·∫•t b·∫°i!")
    
    def restore_database(self):
        """Restore database t·ª´ backup"""
        print("\nüìÇ Restore Database")
        
        # Li·ªát k√™ c√°c file backup
        if os.path.exists("backups"):
            backups = [f for f in os.listdir("backups") if f.endswith('.sql')]
            if backups:
                print("\nüìã C√°c file backup c√≥ s·∫µn:")
                for i, backup in enumerate(backups, 1):
                    size = os.path.getsize(f"backups/{backup}") / (1024 * 1024)
                    print(f"{i}. {backup} ({size:.2f} MB)")
                
                choice = input("\nüìÇ Ch·ªçn s·ªë th·ª© t·ª± file backup: ")
                try:
                    backup_file = f"backups/{backups[int(choice) - 1]}"
                except:
                    print("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!")
                    return
            else:
                print("‚ö†Ô∏è  Kh√¥ng c√≥ file backup n√†o!")
                return
        else:
            print("‚ö†Ô∏è  Th∆∞ m·ª•c backup kh√¥ng t·ªìn t·∫°i!")
            return
        
        confirm = input(f"\n‚ö†Ô∏è  Restore s·∫Ω X√ìA T·∫§T C·∫¢ d·ªØ li·ªáu hi·ªán t·∫°i! Ti·∫øp t·ª•c? (y/N): ")
        if confirm.lower() != 'y':
            print("‚ùå ƒê√£ h·ªßy!")
            return
        
        print(f"‚è≥ ƒêang restore t·ª´ {backup_file}...")
        cmd = f'docker-compose exec -T db psql -U postgres rithmic_db < {backup_file}'
        result = os.system(cmd)
        
        if result == 0:
            print("‚úÖ Restore th√†nh c√¥ng!")
        else:
            print("‚ùå Restore th·∫•t b·∫°i!")
    
    def show_connection_info(self):
        """Hi·ªÉn th·ªã th√¥ng tin k·∫øt n·ªëi"""
        print("\nüîå TH√îNG TIN K·∫æT N·ªêI DATABASE")
        print("-"*60)
        print(f"üè† Host: {self.db_config['host']}")
        print(f"üîå Port: {self.db_config['port']}")
        print(f"üìä Database: {self.db_config['database']}")
        print(f"üë§ User: {self.db_config['user']}")
        print(f"üîë Password: {'*' * len(self.db_config['password'])}")
        print("\nüìù C√¢u l·ªánh k·∫øt n·ªëi:")
        print(f"psql -h {self.db_config['host']} -p {self.db_config['port']} -U {self.db_config['user']} -d {self.db_config['database']}")
        print("\nüê≥ K·∫øt n·ªëi t·ª´ Docker:")
        print("docker-compose exec db psql -U postgres -d rithmic_db")
    
    def run(self):
        """Ch·∫°y ch∆∞∆°ng tr√¨nh ch√≠nh"""
        if not self.connect():
            return
        
        while True:
            self.show_menu()
            choice = input("\nüëâ Ch·ªçn ch·ª©c nƒÉng: ")
            
            try:
                if choice == '0':
                    print("\nüëã T·∫°m bi·ªát!")
                    break
                elif choice == '1':
                    self.show_statistics()
                elif choice == '2':
                    self.show_recent_ticks()
                elif choice == '3':
                    self.show_level2_data()
                elif choice == '4':
                    self.add_symbol()
                elif choice == '5':
                    self.list_symbols()
                elif choice == '6':
                    self.export_to_csv()
                elif choice == '7':
                    self.cleanup_old_data()
                elif choice == '8':
                    self.backup_database()
                elif choice == '9':
                    self.restore_database()
                elif choice == '10':
                    self.show_connection_info()
                else:
                    print("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!")
                
                input("\nüìå Nh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
                
            except Exception as e:
                print(f"\n‚ùå L·ªói: {e}")
                input("\nüìå Nh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
        
        if self.conn:
            self.conn.close()


if __name__ == "__main__":
    print("üöÄ Kh·ªüi ƒë·ªông Database Manager...")
    manager = DatabaseManager()
    manager.run()
